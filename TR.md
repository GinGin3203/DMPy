## Техническое задание

## 1. Шифр = *DMPy*



## 2. Назначение и область применения

Расширяемый пакет целочисленных алгоритмов для проведения вычислительных экспериментов в элементарной части общей алгебры и теории множеств.



## 3. Краткая сводка возможностей

Пакет является расширяемым. В первой версии содержатся средства, которые позволяют манипулировать отношениями, одноместными и двухместными функциями (операциями), заданными на конечном носителе. В том числе, пакет позволяет определять, сохранять, визуализировать, вычислять и преобразовывать сами операции или функции, а также множества и семейства множеств, связанные с этими функциями.



## 4. Варианты использования

Модуль содержит глобальную переменную `DMPy.universum` типа `Support.Support`, нужную для отображения данных, переданных в функции и методы пакета, в числа. Все функции и методы, в которые передаются элементы универсума, должны работать не с самими данными, а с их отображениями, получаемыми с помощью этого объекта. Но каждый метод, принимающий на вход элементы универсума, имеет также аргумент `images = False`, который, если равен `True`, означает, что переданные данные уже преобразованы в числа и второй раз преобразовывать их не нужно.

`DMPy` содержит метод `DMPy.setUniversum( iterable )`, устанавливающий универсум текущей задачи. Он должен проинициализировать  `DMPy.universum` значением  `DMPy.Support.Support( iterable )`. 



### 4.1 Носитель ( =*Support* )

Модуль содержит класс `Support`. Он нужен для того, чтобы преобразовывать фиксированный набор объектов в числа на отрезок 1 ..n и обратно.
 ( на начальном этапе требуется только поддержка базовых хэшируемых типов данных языка Python )

**Конструкторы:**

* `Support( iterable )`  :`iterable` - любой перечислимый объект - заданное рабочее множество.



**Методы:**

* `forth(elem)` возвращает численный образ переданного элемента универсума
* `back(number)` возвращает элемент универсума по его численному образу



Этот модуль предназначен исключительно для использования другими модулями.     



### 4.2 Подмножества и семейства ( =*Sets* )

#### Класс Set

Класс `Set` обеспечивает работу с множествами

**Конструкторы:**

* `Set(iterable)` конструирует множество, состоящее из произвольных элементов универсума, перечисленных в `iterable`.

**Методы:**

* `__contains__(elem)` проверяет, содержится ли `elem` в множестве. `elem` - это элемент универсума
* `__iter__()` возвращает генератор всех элементов множества. 



### 4.3 Одноместные функции ( =*Functions* )

#### Класс Relation

Класс Relation обеспечивает работу с отношениями. 

**Конструкторы:**

* `Relation(graph = None)` строит отношение по переданному графику `graph` - списку пар элементов универсума
* `Relation(criterion = None)` строит такое отношение R, для которого aRb <=> существуют такие элементы универсума `a`, `b`, что criterion(a, b) == True

**Методы:**

* `__contains__(pair)` , где `pair` - кортеж из двух элементов универсума. Позволяет применять операцию in на отношениях ( см. примеры использования )
* ``__iter__()`` - возвращает итератор по всем парам, составляющим график отношения.
* `isFunctional()`
* `isTotal()`
* `isTransitive()`



#### Класс Function

Класс `Function` обеспечивает работу с одноместными функциями. Для него гарантирована функциональность - при попытке определить нефункциональную функцию срабатывает исключение.

**Конструкторы:**

* `Function(procedure = None)` строит функцию, эквивалентную функции `procedure`, принимающей и возвращающей элементы универсума. 

**Методы:**

* `__call__(arg)` - возвращает результат применения функции к элементу универсума `arg`. 
* `periodicalClosure()` возвращает периодическое замыкание функции. 
* `isSurjective()`
* `isInjective()`

**Пример:**

```python
import DMPy

DMPy.setUniversum({'a', 'b', 'c'})

graph = [('a', 'b'), ('b', 'c'), ('c', 'a')]

f = DMpy.Functions.Function(graph=graph)

print(f('a'))  # Должно быть 'b'

if ('a', 'c') in f:
    # Должно быть ложью
    pass
if ('b', 'c') in f:
    # Должно быть истиной
    pass

for pair in f:
    print(pair)  # Должно быть ('a', 'b'), ('b', 'c'), ('c', 'a')
```



#### **Функции:**

* `allRelations()` возвращает генератор, генерирующий все отношения на универсуме.



### 4.4 Двуместные операции ( =*Operations* )

#### Класс Operation

Класс `Operation` обеспечивает работу с операциями.

**Конструкторы:**

* `Operation(graph=None)`  строит операцию по переданному графику `graph` - словарю, проецирующему пары элементов в элементы.
* `Operation(procedure=None)` работает аналогично `Function.Function`, но `procedure` принимает два аргумента.

**Методы:**

* `__contains__(entry)` , где entry - кортеж из пары элементов универсума и её образа. Позволяет применять операцию in на отношениях.
* ``__iter__()`` - возвращает итератор, стоящий график операции
* `__call__(arg1, arg2)` - возвращает результат применения функции к элементам универсума `arg1` и `arg2` .
* `isTotal()`
* `isAssociative()`
* `isCommutative()`
* `hasNeutral()` - имеет ли операция нейтральный элемент
* `hasInverse()` - имеет ли операция обратный элемент



### 4.5 Тестирование ( =*Tests* )

#### Класс SupportTest

**Методы**:

* `test_forth()`
* `test_back()`

#### Класс SetTest

**Методы**:

* `test_set()`

#### Класс FunctionTest

**Методы**:

* `test_relation_isFunctional()`
* `test_relation_isTotal()`
* `test_relation_isTransitive()`
* `test_function_preiodicalClosure()`
* `test_function_isInjective()`
* `test_function_isSurjective()`



### 4.5 Визуализация ( =*Visualization* )

#### **Функции:**

* `drawCycloTree(cycloTree)` - рисует переданный ориентированный граф, учитывая, что это циклодерево.
* `printCayleyTable(operation)` - печатает таблицу Кэли переданной операции



### 4.6 Сериализация ( =*Serialization* )

#### Функции:

* `toStr(obj)` - преобразует произвольный объект встроенного типа Python или экземпляр любого класса любого модуля пакета DMpy в строковый вид в формате JSON. В JSON формате должна сохраняться информация о типе данных объекта для возможности восстановления из строки
* `fromStr(str)` - преобразует объект в JSON формате обратно в объект Python



## 5. Программа и методика испытаний

В этом параграфе приведены тестовые примеры целочисленных экспериментов, позволяющие оценить степень завершённости проекта. Требуется, чтобы в завершённом состоянии весь код из этой главы был рабочим.



### Эксперимент 1: функция Капрекара

```python
import DMPy

DMPy.setUniversum(range(0, 10000))


def Kaprekar_python(n):
    if type(n) != 'str':
        n = str(n).zfill(4)
    to_lowest = sorted(n, reverse=True)
    to_biggest = sorted(n)
    return str(int(to_biggest) - int(to_lowest)).zfill(4)

Kaprekar = DMPy.Functions.Function(procedure=Kaprekar_python)

periodical_closure = Kaprekar.periodicalClosure()

DMpy.Visualization.drawCycloTrees(periodical_closure)
```



### Эксперимент 2: классификация отношений

```python
import DMPy

universum = [[(x, y) for y in range(1, 11)] for x in range(1, 11)]
# universum = (1...10)x(1...10)
DMPy.setUniversum(universum)

for relation in DMPy.Functions.allRelations():
    if relation.isFunctional():
        pass
    if relation.isTotal():
        pass
    if relation.isInjective():
        pass
    if relation.isSurjective():
        pass
```



### Эксперимент 3: построение примеров алгебр

```python
import DMPy

DMPy.setUniversum({0, 1})

for operation in DMPy.Operations.allOperations():
    if operation.isCommutative():
        pass
    if operation.isAssociative():
        pass
    if operation.isSymmetrical():
        pass
    if operation.hasNeutral():
        pass
    if operation.hasInverse():
        pass
    DMPy.Visualization.printCayleyTable(operation)

for op1 in DMPy.Operations.allOperations():
    for op2 in DMPy.Operations.allOperations():
        '''
        Здесь проводится аналогичный анализ op1 и op2,
        и на основе их свойств определяется, какого
        класса алгебра, постренная на op1 и op2
        '''
```
